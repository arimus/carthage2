// Generated by CoffeeScript 1.9.3
(function() {
  var slice = [].slice;

  this.connections = {};

  this.startStreamBroadcast = function(streams) {
    var broadcast, emitters, fn, stream, streamName;
    console.log('startStreamBroadcast');
    InstanceStatus.getCollection().find().observe({
      added: function(record) {
        if (record.extraInformation.port === process.env.PORT || (connections[record.extraInformation.port] != null)) {
          return;
        }
        console.log('connecting in', "localhost:" + record.extraInformation.port);
        return connections[record.extraInformation.port] = DDP.connect("localhost:" + record.extraInformation.port, {
          _dontPrintErrors: true
        });
      },
      removed: function(record) {
        if ((connections[record.extraInformation.port] != null) && (InstanceStatus.getCollection().findOne({
          'extraInformation.port': {
            $ne: record.extraInformation.port
          }
        }) == null)) {
          console.log('disconnecting from', "localhost:" + record.extraInformation.port);
          connections[record.extraInformation.port].disconnect();
          return delete connections[record.extraInformation.port];
        }
      }
    });
    broadcast = function(streamName, eventName, args, userId) {
      var connection, port, results;
      results = [];
      for (port in connections) {
        connection = connections[port];
        if (connection.status().connected === true) {
          console.log('broadcast to', port, streamName, eventName, args);
          results.push(connection.call('stream', streamName, eventName, args));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    Meteor.methods({
      showConnections: function() {
        var connection, data, port;
        data = {};
        for (port in connections) {
          connection = connections[port];
          data[port] = connection.status();
        }
        return data;
      }
    });
    emitters = {};
    fn = function(streamName, stream) {
      emitters[streamName] = stream.emit;
      return stream.emit = function() {
        var args, eventName;
        eventName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        broadcast(streamName, eventName, args);
        return emitters[streamName].apply({}, arguments);
      };
    };
    for (streamName in streams) {
      stream = streams[streamName];
      fn(streamName, stream);
    }
    return Meteor.methods({
      stream: function(streamName, eventName, args) {
        var ref;
        console.log('method stream', streamName, eventName, args);
        args.unshift(eventName);
        return (ref = emitters[streamName]) != null ? ref.apply({}, args) : void 0;
      }
    });
  };

  Meteor.startup(function() {
    if (webrtc) {
      return startStreamBroadcast({
        'webrtc.stream': webrtc.stream,
        'typing': typingStream
      });
    } else {
      return startStreamBroadcast({
        'typing': typingStream
      });
    }
  });

}).call(this);
